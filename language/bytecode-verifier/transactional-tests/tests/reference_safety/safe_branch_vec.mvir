//# publish
module 0x42.NonEmptyVec {
    import 0x1.Vector;
    struct NonEmptyVec<T> has copy, drop, store { inner: vector<T> }
    public new<T>(elem: T): Self.NonEmptyVec<T> {
        return NonEmptyVec<T> { inner: Vector.singleton<T>(move(elem)) };
    }

    public borrow<T>(v: &Self.NonEmptyVec<T>, i: u64): &T {
        return Vector.borrow<T>(&move(v).NonEmptyVec<T>::inner, move(i));
    }

    public borrow_mut<T>(v: &mut Self.NonEmptyVec<T>, i: u64): &mut T {
        return Vector.borrow_mut<T>(&mut move(v).NonEmptyVec<T>::inner, move(i));
    }
}

//# publish
module 0x42.LRUish {
    import 0x42.NonEmptyVec;
    struct Trips {
        bucket1: NonEmptyVec.NonEmptyVec<u64>,
        bucket2: NonEmptyVec.NonEmptyVec<u64>,
        bucket3: NonEmptyVec.NonEmptyVec<u64>,
    }

    update(trips: &mut Self.Trips, new_head: u64) {
        let insertion_point: &mut u64;
        let other_1: &mut NonEmptyVec.NonEmptyVec<u64>;
        let other_2: &mut NonEmptyVec.NonEmptyVec<u64>;
        if (copy(new_head) < 100) {
            insertion_point = NonEmptyVec.borrow_mut<u64>(&mut copy(trips).Trips::bucket1, 0);
            other_1 = &mut copy(trips).Trips::bucket2;
            other_2 = &mut copy(trips).Trips::bucket3;
        } else { if (copy(new_head) < 1000) {
            other_1 = &mut copy(trips).Trips::bucket1;
            insertion_point = NonEmptyVec.borrow_mut<u64>(&mut copy(trips).Trips::bucket2, 0);
            other_2 = &mut copy(trips).Trips::bucket3;
        } else {
            other_1 = &mut copy(trips).Trips::bucket1;
            other_2 = &mut copy(trips).Trips::bucket3;
            insertion_point = NonEmptyVec.borrow_mut<u64>(&mut copy(trips).Trips::bucket2, 0);
        } }
        *NonEmptyVec.borrow_mut<u64>(copy(other_1), 0) =
            *NonEmptyVec.borrow<u64>(freeze(copy(other_2)), 0);
        *NonEmptyVec.borrow_mut<u64>(copy(other_2), 0) =
            *NonEmptyVec.borrow<u64>(freeze(copy(other_1)), 0);
        *move(insertion_point) =
            move(new_head) + *NonEmptyVec.borrow<u64>(freeze(copy(other_1)), 0);
        return;
    }

}
